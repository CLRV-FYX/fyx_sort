
/*
 * FYX-SORT v2.0
 * 一个实用的C++排序库
 * 
 * 我写这个是因为std::sort在一些场景下不够快：
 * 1. 对整数用基数排序会快很多
 * 2. 大对象来回拷贝太浪费，应该只排索引
 * 3. 数据量大时应该自动开多线程
 * 4. 已经有序的数据应该直接跳过
 * 
 * 特性：
 * - 自适应算法选择
 * - 自动并行化（数据量大时）
 * - 大对象优化（用索引排序）
 * - STL兼容API，零配置
 * 
 * 用法：
 *   #include "fyx_sort.hpp"
 *   fyx::sort(data);                    // 原地排序
 *   auto sorted = fyx::sorted(data);    // 返回副本
 *   fyx::stable_sort(data);             // 稳定排序
 * 
 * 许可证：MIT
 * 作者：你（或者你的GitHub用户名）
 * 
 * 注意：这个库还在完善中，有问题欢迎提issue
 */

#ifndef FYX_SORT_HPP
#define FYX_SORT_HPP

// 版本号
#define FYX_SORT_VERSION_MAJOR 2
#define FYX_SORT_VERSION_MINOR 0
#define FYX_SORT_VERSION_PATCH 0
#define FYX_SORT_VERSION "2.0.0"

// 编译器检测，不同编译器有不同优化
#if defined(_MSC_VER)
    #define FYX_MSVC 1
    #define FYX_COMPILER_VER _MSC_VER
#elif defined(__clang__)
    #define FYX_CLANG 1
    #define FYX_COMPILER_VER (__clang_major__ * 10000 + __clang_minor__ * 100)
#elif defined(__GNUC__)
    #define FYX_GCC 1
    #define FYX_COMPILER_VER (__GNUC__ * 10000 + __GNUC_MINOR__ * 100)
#endif

// GCC的一些警告屏蔽，有些优化会触发警告但实际没问题
#if defined(FYX_GCC) && FYX_COMPILER_VER >= 110000
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wstringop-overflow"
    #pragma GCC diagnostic ignored "-Warray-bounds"
#endif

// 用户可调的配置，可以在包含头文件前定义这些
#ifndef FYX_ENABLE_PARALLEL
    #define FYX_ENABLE_PARALLEL 1  // 默认开并行，关掉就是单线程
#endif

#ifndef FYX_ENABLE_AVX2
    #define FYX_ENABLE_AVX2 1      // 有AVX2的话用上会更快
#endif

// 标准库头文件
#include <cstdint>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <type_traits>
#include <iterator>
#include <thread>
#include <vector>
#include <array>
#include <deque>
#include <list>
#include <string>
#include <string_view>
#include <functional>
#include <utility>
#include <limits>
#include <numeric>
#include <optional>
#include <tuple>

#if defined(_MSC_VER) || defined(__MINGW32__)
    #include <malloc.h>  // Windows的特殊内存分配
#endif

// SIMD头文件，有就用上
#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
    #define FYX_X86 1
    #if defined(__AVX2__) && FYX_ENABLE_AVX2
        #include <immintrin.h>
        #define FYX_AVX2 1
    #elif defined(__SSE4_2__)
        #include <nmmintrin.h>
        #define FYX_SSE42 1
    #elif defined(__SSE2__) || defined(_M_X64)
        #include <emmintrin.h>
        #define FYX_SSE2 1
    #endif
#elif defined(__aarch64__) || defined(_M_ARM64)
    #include <arm_neon.h>
    #define FYX_NEON 1
#endif

// 编译器特性
#ifdef FYX_MSVC
    #define FYX_INLINE __forceinline
    #define FYX_NOINLINE __declspec(noinline)
    #define FYX_RESTRICT __restrict
    #define FYX_LIKELY(x) (x)
    #define FYX_UNLIKELY(x) (x)
#else
    #define FYX_INLINE inline __attribute__((always_inline))
    #define FYX_NOINLINE __attribute__((noinline))
    #define FYX_RESTRICT __restrict__
    #define FYX_LIKELY(x) __builtin_expect(!!(x), 1)
    #define FYX_UNLIKELY(x) __builtin_expect(!!(x), 0)
#endif

namespace fyx {

// 前向声明
template<typename T> struct Sorter;

// 排序选项
struct Options {
    bool parallel = true;               // 开并行
    bool stable = false;                // 稳定排序
    size_t parallel_threshold = 50000;  // 并行阈值，调过几次这个值比较合适
    size_t max_threads = 0;             // 0表示自动检测
    
    // 一些预设
    static Options default_opts() { return Options{}; }
    static Options sequential() { Options o; o.parallel = false; return o; }
    static Options stable_sort() { Options o; o.stable = true; return o; }
};

// 内部实现，用户不用关心这里
namespace detail {

// 一些配置常量，调参调出来的
struct Config {
    static constexpr size_t CACHE_LINE = 64;   // 缓存行大小
    static constexpr size_t TINY = 8;          // 8个以下用排序网络
    static constexpr size_t SMALL = 32;        // 32个以下用插入排序
    static constexpr size_t RADIX_BITS = 8;    // 基数排序每次处理8位
    static constexpr size_t BUCKETS = 256;     // 256个桶
    static constexpr size_t OBJ_SMALL = 32;    // 小对象阈值
    static constexpr size_t OBJ_MEDIUM = 128;  // 中对象阈值
    static constexpr size_t OBJ_LARGE = 256;   // 大对象阈值
    static constexpr size_t STREAM_MIN = 100000; // 用LSD基数排序的最小大小
    
    // 获取CPU核心数
    static size_t threads() noexcept {
        static const size_t n = []() {
            auto hw = std::thread::hardware_concurrency();
            return hw > 0 ? static_cast<size_t>(hw) : 1;
        }();
        return n;
    }
};

// 类型特征
namespace traits {

template<typename T>
inline constexpr bool is_radix_v = std::is_integral_v<T> || std::is_floating_point_v<T>;

template<typename T>
inline constexpr bool is_string_v = 
    std::is_same_v<std::decay_t<T>, std::string> ||
    std::is_same_v<std::decay_t<T>, std::string_view>;

template<typename T>
inline constexpr bool is_trivial_v = 
    std::is_trivially_copyable_v<T> && std::is_trivially_destructible_v<T>;

// 对象大小分类
enum class Size { TINY, SMALL, MEDIUM, LARGE, XLARGE };

template<typename T>
constexpr Size size_of() noexcept {
    if constexpr (sizeof(T) <= 8) return Size::TINY;
    else if constexpr (sizeof(T) <= Config::OBJ_SMALL) return Size::SMALL;
    else if constexpr (sizeof(T) <= Config::OBJ_MEDIUM) return Size::MEDIUM;
    else if constexpr (sizeof(T) <= Config::OBJ_LARGE) return Size::LARGE;
    else return Size::XLARGE;
}

// 检测是否是连续内存容器
template<typename T, typename = void>
struct has_data : std::false_type {};
template<typename T>
struct has_data<T, std::void_t<decltype(std::declval<T>().data())>> : std::true_type {};

template<typename T, typename = void>
struct has_size : std::false_type {};
template<typename T>
struct has_size<T, std::void_t<decltype(std::declval<T>().size())>> : std::true_type {};

template<typename T>
inline constexpr bool is_contiguous_v = has_data<T>::value && has_size<T>::value;

} // namespace traits

// 内存管理
namespace mem {

// 对齐分配，对SIMD友好
inline void* alloc(size_t sz, size_t align) noexcept {
    if (!sz) return nullptr;
#if defined(_MSC_VER) || defined(__MINGW32__)
    return _aligned_malloc(sz, align);
#else
    void* p = nullptr;
    return posix_memalign(&p, align, sz) == 0 ? p : nullptr;
#endif
}

inline void dealloc(void* p) noexcept {
    if (!p) return;
#if defined(_MSC_VER) || defined(__MINGW32__)
    _aligned_free(p);
#else
    ::free(p);
#endif
}

// 拷贝函数，平凡类型用memmove更快
template<typename T>
FYX_NOINLINE void copy(T* FYX_RESTRICT dst, const T* FYX_RESTRICT src, size_t n) noexcept {
    if constexpr (traits::is_trivial_v<T>) {
        std::memmove(dst, src, n * sizeof(T));
    } else {
        for (size_t i = 0; i < n; ++i) dst[i] = src[i];
    }
}

} // namespace mem

// 基础操作
namespace ops {

template<typename T>
FYX_INLINE void swap(T& a, T& b) noexcept {
    T t = std::move(a);
    a = std::move(b);
    b = std::move(t);
}

// 比较并交换
template<typename T, typename Cmp>
FYX_INLINE void cas(T& a, T& b, Cmp& c) noexcept {
    if (c(b, a)) swap(a, b);
}

template<typename T>
FYX_INLINE void cas(T& a, T& b) noexcept {
    if (b < a) swap(a, b);
}

} // namespace ops

// 势能映射，用于处理有符号数和浮点数
namespace pot {

template<typename T, typename = void> struct Map;

// 有符号整数：把符号位反转一下
template<typename T>
struct Map<T, std::enable_if_t<std::is_integral_v<T> && std::is_signed_v<T>>> {
    using U = std::make_unsigned_t<T>;
    static constexpr U F = U(1) << (sizeof(T) * 8 - 1);
    static FYX_INLINE U to(T v) noexcept { return U(v) ^ F; }
};

// 无符号整数：直接返回
template<typename T>
struct Map<T, std::enable_if_t<std::is_integral_v<T> && std::is_unsigned_v<T>>> {
    using U = T;
    static FYX_INLINE U to(T v) noexcept { return v; }
};

// float：处理符号位和指数
template<> struct Map<float> {
    using U = uint32_t;
    static FYX_INLINE U to(float v) noexcept {
        U b; std::memcpy(&b, &v, 4);
        return b ^ (static_cast<U>(-static_cast<int32_t>(b >> 31)) | 0x80000000U);
    }
};

// double：同上
template<> struct Map<double> {
    using U = uint64_t;
    static FYX_INLINE U to(double v) noexcept {
        U b; std::memcpy(&b, &v, 8);
        return b ^ (static_cast<U>(-static_cast<int64_t>(b >> 63)) | 0x8000000000000000ULL);
    }
};

// string：取前8个字节
template<> struct Map<std::string> {
    using U = uint64_t;
    static FYX_INLINE U to(const std::string& s) noexcept {
        U r = 0;
        size_t l = s.size() < 8 ? s.size() : 8;
        for (size_t i = 0; i < l; ++i) r = (r << 8) | static_cast<unsigned char>(s[i]);
        return r << ((8 - l) * 8);
    }
};

template<> struct Map<std::string_view> {
    using U = uint64_t;
    static FYX_INLINE U to(std::string_view s) noexcept {
        U r = 0;
        size_t l = s.size() < 8 ? s.size() : 8;
        for (size_t i = 0; i < l; ++i) r = (r << 8) | static_cast<unsigned char>(s[i]);
        return r << ((8 - l) * 8);
    }
};

} // namespace pot

// SIMD排序，有AVX2的话会快很多
#ifdef FYX_AVX2
namespace simd {

FYX_INLINE __m256i sort8i(__m256i v) noexcept {
    // bitonic排序网络的AVX2实现
    auto step = [](auto& x, int m, int b) {
        auto p = _mm256_shuffle_epi32(x, m);
        x = _mm256_blend_epi32(_mm256_min_epi32(x, p), _mm256_max_epi32(x, p), b);
    };
    step(v, 0xB1, 0xAA); step(v, 0x4E, 0xCC); step(v, 0xB1, 0xAA);
    auto p = _mm256_permute2x128_si256(v, v, 0x01);
    v = _mm256_blend_epi32(_mm256_min_epi32(v, p), _mm256_max_epi32(v, p), 0xF0);
    step(v, 0x4E, 0xCC); step(v, 0xB1, 0xAA);
    return v;
}

} // namespace simd
#endif

// 排序网络，对小数组特别有效
namespace net {

template<typename T, typename C = std::less<T>>
struct Sort {
    static void run(T* a, size_t n, C c = C()) noexcept {
        // 硬编码的排序网络，展开后很快
        switch(n) {
            case 0: case 1: return;
            case 2: ops::cas(a[0], a[1], c); return;
            case 3: s3(a, c); return;
            case 4: s4(a, c); return;
            case 5: s5(a, c); return;
            case 6: s6(a, c); return;
            case 7: s7(a, c); return;
            case 8: s8(a, c); return;
            default: break;
        }
    }

private:
    // 3个元素
    static FYX_INLINE void s3(T* a, C& c) noexcept {
        ops::cas(a[0], a[1], c); ops::cas(a[1], a[2], c); ops::cas(a[0], a[1], c);
    }
    
    // 4个元素
    static FYX_INLINE void s4(T* a, C& c) noexcept {
        ops::cas(a[0], a[1], c); ops::cas(a[2], a[3], c);
        ops::cas(a[0], a[2], c); ops::cas(a[1], a[3], c); ops::cas(a[1], a[2], c);
    }
    
    // 5个元素
    static FYX_INLINE void s5(T* a, C& c) noexcept {
        ops::cas(a[0], a[1], c); ops::cas(a[3], a[4], c); ops::cas(a[2], a[4], c);
        ops::cas(a[2], a[3], c); ops::cas(a[1], a[4], c); ops::cas(a[0], a[3], c);
        ops::cas(a[0], a[2], c); ops::cas(a[1], a[3], c); ops::cas(a[1], a[2], c);
    }
    
    // 6个元素
    static FYX_INLINE void s6(T* a, C& c) noexcept {
        ops::cas(a[1], a[2], c); ops::cas(a[4], a[5], c); ops::cas(a[0], a[2], c);
        ops::cas(a[3], a[5], c); ops::cas(a[0], a[1], c); ops::cas(a[3], a[4], c);
        ops::cas(a[2], a[5], c); ops::cas(a[0], a[3], c); ops::cas(a[1], a[4], c);
        ops::cas(a[2], a[4], c); ops::cas(a[1], a[3], c); ops::cas(a[2], a[3], c);
    }
    
    // 7个元素
    static FYX_INLINE void s7(T* a, C& c) noexcept {
        ops::cas(a[1], a[2], c); ops::cas(a[3], a[4], c); ops::cas(a[5], a[6], c);
        ops::cas(a[0], a[2], c); ops::cas(a[3], a[5], c); ops::cas(a[4], a[6], c);
        ops::cas(a[0], a[1], c); ops::cas(a[4], a[5], c); ops::cas(a[2], a[6], c);
        ops::cas(a[0], a[4], c); ops::cas(a[1], a[5], c); ops::cas(a[0], a[3], c);
        ops::cas(a[2], a[5], c); ops::cas(a[1], a[3], c); ops::cas(a[2], a[4], c);
        ops::cas(a[2], a[3], c);
    }
    
    // 8个元素，有AVX2用SIMD
    static FYX_INLINE void s8(T* a, C& c) noexcept {
#ifdef FYX_AVX2
        if constexpr (std::is_same_v<T, int32_t> && std::is_same_v<C, std::less<int32_t>>) {
            auto v = _mm256_loadu_si256(reinterpret_cast<__m256i*>(a));
            _mm256_storeu_si256(reinterpret_cast<__m256i*>(a), simd::sort8i(v));
            return;
        }
#endif
        ops::cas(a[0], a[1], c); ops::cas(a[2], a[3], c);
        ops::cas(a[4], a[5], c); ops::cas(a[6], a[7], c);
        ops::cas(a[0], a[2], c); ops::cas(a[1], a[3], c);
        ops::cas(a[4], a[6], c); ops::cas(a[5], a[7], c);
        ops::cas(a[1], a[2], c); ops::cas(a[5], a[6], c);
        ops::cas(a[0], a[4], c); ops::cas(a[1], a[5], c);
        ops::cas(a[2], a[6], c); ops::cas(a[3], a[7], c);
        ops::cas(a[2], a[4], c); ops::cas(a[3], a[5], c);
        ops::cas(a[1], a[2], c); ops::cas(a[3], a[4], c); ops::cas(a[5], a[6], c);
    }
};

} // namespace net

// 插入排序，对几乎有序的数据很快
namespace ins {

template<typename T, typename C = std::less<T>>
FYX_NOINLINE void sort(T* a, size_t n, C c = C()) noexcept {
    if (n <= 1) return;
    if (n <= 8) { net::Sort<T, C>::run(a, n, c); return; }
    
    // 先把最小值放到最前面，减少后续比较
    size_t m = 0;
    for (size_t i = 1; i < n; ++i) if (c(a[i], a[m])) m = i;
    if (m != 0) ops::swap(a[0], a[m]);
    
    // 标准插入排序
    for (size_t i = 2; i < n; ++i) {
        T key = std::move(a[i]);
        size_t j = i;
        while (c(key, a[j - 1])) {
            a[j] = std::move(a[j - 1]);
            --j;
        }
        a[j] = std::move(key);
    }
}

// 字符串插入排序
template<typename S>
void str_sort(S* a, size_t n, size_t d) noexcept {
    if (n <= 1) return;
    auto cmp = [d](const S& x, const S& y) -> bool {
        size_t lx = x.size(), ly = y.size();
        if (d >= lx) return d < ly;
        if (d >= ly) return false;
        size_t rx = lx - d, ry = ly - d, m = rx < ry ? rx : ry;
        int r = std::memcmp(x.data() + d, y.data() + d, m);
        return r < 0 || (r == 0 && rx < ry);
    };
    for (size_t i = 1; i < n; ++i) {
        S key = std::move(a[i]);
        size_t j = i;
        while (j > 0 && cmp(key, a[j - 1])) {
            a[j] = std::move(a[j - 1]);
            --j;
        }
        a[j] = std::move(key);
    }
}

} // namespace ins

// 堆排序，递归太深时的备用方案
namespace heap {

template<typename T, typename C = std::less<T>>
void sort(T* a, size_t n, C c = C()) noexcept {
    if (n <= 1) return;
    
    auto down = [&](size_t s, size_t e) {
        size_t r = s;
        while (2 * r + 1 < e) {
            size_t ch = 2 * r + 1, sw = r;
            if (c(a[sw], a[ch])) sw = ch;
            if (ch + 1 < e && c(a[sw], a[ch + 1])) sw = ch + 1;
            if (sw == r) return;
            ops::swap(a[r], a[sw]);
            r = sw;
        }
    };
    
    // 建堆
    for (size_t i = n / 2; i > 0; --i) down(i - 1, n);
    
    // 依次取出最大值
    for (size_t i = n - 1; i > 0; --i) {
        ops::swap(a[0], a[i]);
        down(0, i);
    }
}

} // namespace heap

// 归并排序，稳定排序用
namespace merge {

template<typename T, typename C = std::less<T>>
void sort(T* a, size_t n, C c = C()) {
    if (n <= Config::SMALL) { ins::sort(a, n, c); return; }
    
    std::vector<T> buf(n);
    std::function<void(size_t, size_t)> go = [&](size_t lo, size_t hi) {
        size_t len = hi - lo;
        if (len <= Config::SMALL) { ins::sort(a + lo, len, c); return; }
        
        size_t mid = lo + len / 2;
        go(lo, mid);
        go(mid, hi);
        
        // 如果已经有序，直接返回
        if (!c(a[mid], a[mid - 1])) return;
        
        // 合并
        for (size_t i = lo; i < hi; ++i) buf[i] = std::move(a[i]);
        size_t i = lo, j = mid, k = lo;
        while (i < mid && j < hi)
            a[k++] = std::move(!c(buf[j], buf[i]) ? buf[i++] : buf[j++]);
        while (i < mid) a[k++] = std::move(buf[i++]);
        while (j < hi) a[k++] = std::move(buf[j++]);
    };
    
    go(0, n);
}

} // namespace merge

// 基数排序，对整数和浮点数特别快
namespace radix {

// MSD基数排序，适合中等大小数据
template<typename T> struct MSD {
    using M = pot::Map<T>;
    using U = typename M::U;
    static constexpr int BITS = sizeof(U) * 8;
    static constexpr size_t R = Config::RADIX_BITS, B = Config::BUCKETS;
    
    static void sort(T* a, size_t n) {
        if (n <= Config::SMALL) { ins::sort(a, n); return; }
        go(a, 0, n, BITS - int(R));
    }
    
private:
    static void go(T* a, size_t lo, size_t hi, int sh) {
        size_t n = hi - lo;
        if (n <= Config::SMALL) { ins::sort(a + lo, n); return; }
        if (sh < 0) return;
        
        size_t cnt[B + 1] = {0};
        for (size_t i = lo; i < hi; ++i) ++cnt[((M::to(a[i]) >> sh) & (B - 1)) + 1];
        for (size_t j = 1; j <= B; ++j) cnt[j] += cnt[j - 1];
        
        size_t hd[B];
        for (size_t j = 0; j < B; ++j) hd[j] = lo + cnt[j];
        
        // 原地重排
        for (size_t bkt = 0; bkt < B; ++bkt) {
            while (hd[bkt] < lo + cnt[bkt + 1]) {
                T v = std::move(a[hd[bkt]]);
                size_t t = (M::to(v) >> sh) & (B - 1);
                while (t != bkt) {
                    ops::swap(v, a[hd[t]++]);
                    t = (M::to(v) >> sh) & (B - 1);
                }
                a[hd[bkt]++] = std::move(v);
            }
        }
        
        // 递归处理每个桶
        if (sh >= int(R)) {
            size_t st = lo;
            for (size_t bkt = 0; bkt < B; ++bkt) {
                size_t ed = lo + cnt[bkt + 1];
                if (ed - st > 1) go(a, st, ed, sh - int(R));
                st = ed;
            }
        }
    }
};

// LSD基数排序，适合大数据流式处理
template<typename T> struct LSD {
    using M = pot::Map<T>;
    using U = typename M::U;
    static constexpr size_t BITS = sizeof(U) * 8, R = Config::RADIX_BITS;
    static constexpr size_t B = Config::BUCKETS, P = BITS / R;
    
    static void sort(T* a, size_t n) {
        if (n <= Config::SMALL) { ins::sort(a, n); return; }
        
        T* buf = static_cast<T*>(mem::alloc(n * sizeof(T), Config::CACHE_LINE));
        if (!buf) { MSD<T>::sort(a, n); return; }
        
        T *src = a, *dst = buf;
        size_t cnt[B + 1];
        
        // 多趟排序
        for (size_t p = 0; p < P; ++p) {
            size_t sh = p * R;
            std::memset(cnt, 0, sizeof(cnt));
            
            // 计数
            for (size_t i = 0; i < n; ++i) ++cnt[((M::to(src[i]) >> sh) & (B - 1)) + 1];
            
            // 前缀和
            for (size_t j = 1; j <= B; ++j) cnt[j] += cnt[j - 1];
            
            // 分布
            for (size_t i = 0; i < n; ++i) {
                T v = src[i];
                dst[cnt[(M::to(v) >> sh) & (B - 1)]++] = v;
            }
            
            // 交换角色
            T* t = src; src = dst; dst = t;
        }
        
        // 如果最后结果在缓冲区里，拷贝回来
        if (src != a) mem::copy(a, src, n);
        mem::dealloc(buf);
    }
};

} // namespace radix

// 字符串排序
namespace strsort {

template<typename S>
void sort(S* a, size_t n) {
    if (n <= Config::SMALL) { std::sort(a, a + n); return; }
    
    constexpr size_t B = 257;  // 256个字符 + 空字符
    std::function<void(size_t, size_t, size_t)> go = [&](size_t lo, size_t hi, size_t d) {
        size_t len = hi - lo;
        if (len <= Config::SMALL) { ins::str_sort(a + lo, len, d); return; }
        
        auto at = [](const S& s, size_t i) -> size_t {
            return i < s.size() ? static_cast<unsigned char>(s[i]) + 1 : 0;
        };
        
        size_t cnt[B + 1] = {0};
        for (size_t i = lo; i < hi; ++i) ++cnt[at(a[i], d) + 1];
        for (size_t j = 1; j <= B; ++j) cnt[j] += cnt[j - 1];
        
        std::vector<S> aux(len);
        for (size_t i = lo; i < hi; ++i) {
            size_t c = at(a[i], d);
            aux[cnt[c]++] = std::move(a[i]);
        }
        
        for (size_t i = 0; i < len; ++i) a[lo + i] = std::move(aux[i]);
        
        // 递归处理每个桶
        for (size_t j = B; j > 0; --j) cnt[j] = cnt[j - 1];
        cnt[0] = 0;
        
        for (size_t c = 1; c < B; ++c) {
            size_t st = lo + cnt[c], ed = lo + cnt[c + 1];
            if (ed - st > 1) go(st, ed, d + 1);
        }
    };
    
    go(0, n, 0);
}

} // namespace strsort

// 快速排序，通用排序算法
namespace quick {

template<typename T, typename C = std::less<T>>
struct Sort3 {
    C cmp;
    explicit Sort3(C c = C()) : cmp(c) {}
    
    void sort(T* a, size_t n) {
        if (n <= Config::TINY) { net::Sort<T, C>::run(a, n, cmp); return; }
        if (n <= Config::SMALL) { ins::sort(a, n, cmp); return; }
        go(a, n, 2 * lg(n));  // 限制递归深度
    }
    
private:
    // 计算对数
    static size_t lg(size_t n) noexcept { 
        size_t r = 0; 
        while (n > 1) { n >>= 1; ++r; } 
        return r; 
    }
    
    void go(T* a, size_t n, int d) {
        while (n > Config::SMALL) {
            if (d <= 0) { heap::sort(a, n, cmp); return; }  // 递归太深转堆排序
            --d;
            
            T piv = med(a, n);  // 选一个好的pivot
            auto [lt, gt] = part(a, n, piv);
            
            // 递归处理小的部分，循环处理大的部分
            size_t ln = lt, rn = n - gt;
            if (ln < rn) {
                go(a, ln, d);
                a += gt;
                n = rn;
            } else {
                go(a + gt, rn, d);
                n = ln;
            }
        }
        ins::sort(a, n, cmp);
    }
    
    // 三取样中值法选pivot
    T med(T* a, size_t n) const {
        auto m3 = [this](T* x, T* y, T* z) -> T* {
            return cmp(*x, *y) ? (cmp(*y, *z) ? y : (cmp(*x, *z) ? z : x))
                               : (cmp(*x, *z) ? x : (cmp(*y, *z) ? z : y));
        };
        
        if (n <= 40) return *m3(a, a + n / 2, a + n - 1);
        
        // 对大数据集，多取几个样本
        size_t s = n / 8;
        return *m3(m3(a, a + s, a + 2 * s),
                   m3(a + 3 * s, a + 4 * s, a + 5 * s),
                   m3(a + 6 * s, a + 7 * s, a + n - 1));
    }
    
    // 三路划分，处理重复元素
    std::pair<size_t, size_t> part(T* a, size_t n, const T& piv) {
        size_t lt = 0, i = 0, gt = n;
        while (i < gt) {
            if (cmp(a[i], piv)) {
                ops::swap(a[lt++], a[i++]);
            } else if (cmp(piv, a[i])) {
                ops::swap(a[i], a[--gt]);
            } else {
                ++i;
            }
        }
        return {lt, gt};
    }
};

} // namespace quick

// 间接排序，对大对象很有效
namespace indirect {

template<typename T>
void apply_perm(T* a, size_t n, std::vector<size_t>& perm) {
    std::vector<bool> done(n, false);
    for (size_t i = 0; i < n; ++i) {
        if (done[i] || perm[i] == i) continue;
        
        size_t curr = i;
        T tmp = std::move(a[i]);
        
        while (perm[curr] != i) {
            size_t next = perm[curr];
            a[curr] = std::move(a[next]);
            done[curr] = true;
            curr = next;
        }
        
        a[curr] = std::move(tmp);
        done[curr] = true;
    }
}

template<typename T, typename C = std::less<T>>
void sort(T* a, size_t n, C c = C()) {
    if (n <= 1) return;
    if (n <= Config::SMALL) { ins::sort(a, n, c); return; }
    
    std::vector<size_t> idx(n);
    std::iota(idx.begin(), idx.end(), size_t(0));
    std::sort(idx.begin(), idx.end(), [&](size_t x, size_t y) { return c(a[x], a[y]); });
    
    apply_perm(a, n, idx);
}

template<typename T, typename C = std::less<T>>
void stable_sort(T* a, size_t n, C c = C()) {
    if (n <= 1) return;
    if (n <= Config::SMALL) { merge::sort(a, n, c); return; }
    
    std::vector<size_t> idx(n);
    std::iota(idx.begin(), idx.end(), size_t(0));
    std::stable_sort(idx.begin(), idx.end(), [&](size_t x, size_t y) { return c(a[x], a[y]); });
    
    apply_perm(a, n, idx);
}

} // namespace indirect

// 并行排序
#if FYX_ENABLE_PARALLEL
namespace par {

template<typename T, typename F>
void sort(T* a, size_t n, F seq, const Options& opts) {
    size_t nt = opts.max_threads > 0 ? opts.max_threads : Config::threads();
    if (n < opts.parallel_threshold || nt <= 1 || !opts.parallel) {
        seq(a, n);
        return;
    }
    
    // 采样选取分割点
    size_t sn = nt * 64;
    if (sn > n) sn = n;
    
    std::vector<T> samp(sn);
    for (size_t i = 0; i < sn; ++i) samp[i] = a[i * n / sn];
    std::sort(samp.begin(), samp.end());
    
    std::vector<T> sp(nt - 1);
    for (size_t i = 0; i < nt - 1; ++i) sp[i] = samp[(i + 1) * sn / nt];
    
    // 数据分区
    std::vector<std::vector<T>> bkt(nt);
    for (auto& b : bkt) b.reserve(n / nt + n / (nt * 4));
    
    for (size_t i = 0; i < n; ++i) {
        size_t b = size_t(std::lower_bound(sp.begin(), sp.end(), a[i]) - sp.begin());
        bkt[b].push_back(std::move(a[i]));
    }
    
    // 并行排序每个分区
    std::vector<std::thread> th;
    th.reserve(nt);
    for (size_t t = 0; t < nt; ++t) {
        th.emplace_back([&, t] {
            if (!bkt[t].empty()) seq(bkt[t].data(), bkt[t].size());
        });
    }
    
    for (auto& t : th) t.join();
    
    // 合并结果
    size_t pos = 0;
    for (auto& b : bkt) {
        std::move(b.begin(), b.end(), a + pos);
        pos += b.size();
    }
}

} // namespace par
#endif

// 数据分析，看看数据是什么样的
namespace analyze {

template<typename T>
struct Info {
    bool sorted = false;   // 是否已排序
    bool rev = false;      // 是否完全逆序
    bool nearly = false;   // 是否几乎有序
};

template<typename T>
Info<T> check(const T* a, size_t n) noexcept {
    Info<T> r;
    if (n <= 1) { r.sorted = true; return r; }
    
    // 小数组直接检查
    if (n <= 1000) {
        bool s = true, rv = true;
        for (size_t i = 1; i < n; ++i) {
            if (a[i] < a[i - 1]) s = false;
            if (a[i - 1] < a[i]) rv = false;
            if (!s && !rv) break;
        }
        r.sorted = s;
        r.rev = rv && !s;
        return r;
    }
    
    // 大数组抽样检查
    size_t st = n / 256;
    size_t asc = 0, desc = 0;
    
    for (size_t i = 1; i < 256; ++i) {
        size_t p = (i - 1) * st, c = i * st;
        if (a[c] < a[p]) ++desc;
        else if (a[p] < a[c]) ++asc;
    }
    
    if (asc > 250 && !desc) {
        // 很可能已排序，确认一下
        r.sorted = true;
        for (size_t i = 1; i < n; ++i) {
            if (a[i] < a[i - 1]) {
                r.sorted = false;
                break;
            }
        }
    } else if (desc > 250 && !asc) {
        // 很可能完全逆序
        r.rev = true;
        for (size_t i = 1; i < n; ++i) {
            if (a[i - 1] < a[i]) {
                r.rev = false;
                break;
            }
        }
    }
    
    r.nearly = asc > 230;
    return r;
}

} // namespace analyze

} // namespace detail

// 主排序器：根据数据类型和特征选择算法
template<typename T>
struct Sorter {
    static void sort(T* a, size_t n, const Options& opts = Options::default_opts()) {
        if (n < 2) return;
        
        // 小数组直接处理
        if (n <= detail::Config::TINY) {
            detail::net::Sort<T>::run(a, n);
            return;
        }
        if (n <= detail::Config::SMALL) {
            detail::ins::sort(a, n);
            return;
        }
        
        // 稳定排序
        if (opts.stable) {
            stable_sort(a, n, opts);
            return;
        }
        
        // 检查数据特征
        auto info = detail::analyze::check(a, n);
        if (info.sorted) return;  // 已经排好序了
        if (info.rev) {           // 完全逆序，反转就行
            std::reverse(a, a + n);
            return;
        }
        
        // 根据类型选算法
        if constexpr (detail::traits::is_radix_v<T>) {
            sort_num(a, n, info, opts);
        } else if constexpr (detail::traits::is_string_v<T>) {
            sort_str(a, n, opts);
        } else {
            sort_obj(a, n, opts);
        }
    }
    
    template<typename C>
    static void sort(T* a, size_t n, C c, const Options& opts = Options::default_opts()) {
        if (n < 2) return;
        if (opts.stable) {
            stable_sort(a, n, c, opts);
            return;
        }
        sort_cmp(a, n, c, opts);
    }
    
    static void stable_sort(T* a, size_t n, const Options& opts = Options::default_opts()) {
        if (n < 2) return;
        stable_impl(a, n, opts);
    }
    
    template<typename C>
    static void stable_sort(T* a, size_t n, C c, const Options& = Options::default_opts()) {
        if (n < 2) return;
        stable_cmp(a, n, c);
    }

private:
    // 数字排序（整数、浮点数）
    static void sort_num(T* a, size_t n, const detail::analyze::Info<T>& info, const Options& opts) {
        // 几乎有序的小数组用插入排序
        if (info.nearly && n <= 5000) {
            detail::ins::sort(a, n);
            return;
        }
        
        auto seq = [](T* x, size_t m) {
            if (m > detail::Config::STREAM_MIN) detail::radix::LSD<T>::sort(x, m);
            else detail::radix::MSD<T>::sort(x, m);
        };
        
#if FYX_ENABLE_PARALLEL
        if (opts.parallel && n >= opts.parallel_threshold && detail::Config::threads() > 1)
            detail::par::sort(a, n, seq, opts);
        else seq(a, n);
#else
        (void)opts; seq(a, n);
#endif
    }
    
    // 字符串排序
    static void sort_str(T* a, size_t n, const Options& opts) {
        auto seq = [](T* x, size_t m) { detail::strsort::sort(x, m); };
        
#if FYX_ENABLE_PARALLEL
        if (opts.parallel && n >= opts.parallel_threshold && detail::Config::threads() > 1)
            detail::par::sort(a, n, seq, opts);
        else seq(a, n);
#else
        (void)opts; seq(a, n);
#endif
    }
    
    // 对象排序
    static void sort_obj(T* a, size_t n, const Options& opts) {
        constexpr auto sz = detail::traits::size_of<T>();
        
        if constexpr (sz == detail::traits::Size::TINY || sz == detail::traits::Size::SMALL) {
            auto seq = [](T* x, size_t m) { detail::quick::Sort3<T>().sort(x, m); };
            
#if FYX_ENABLE_PARALLEL
            if (opts.parallel && n >= opts.parallel_threshold && detail::Config::threads() > 1)
                detail::par::sort(a, n, seq, opts);
            else seq(a, n);
#else
            (void)opts; seq(a, n);
#endif
        } else if constexpr (sz == detail::traits::Size::MEDIUM) {
            if (n <= 1000) detail::quick::Sort3<T>().sort(a, n);
            else detail::indirect::sort(a, n);
        } else {
            if (n <= 100) detail::quick::Sort3<T>().sort(a, n);
            else detail::indirect::sort(a, n);
        }
    }
    
    template<typename C>
    static void sort_cmp(T* a, size_t n, C c, const Options&) {
        constexpr auto sz = detail::traits::size_of<T>();
        if constexpr (sz == detail::traits::Size::XLARGE || sz == detail::traits::Size::LARGE)
            detail::indirect::sort(a, n, c);
        else detail::quick::Sort3<T, C>(c).sort(a, n);
    }
    
    static void stable_impl(T* a, size_t n, const Options&) {
        constexpr auto sz = detail::traits::size_of<T>();
        if constexpr (sz == detail::traits::Size::TINY || sz == detail::traits::Size::SMALL)
            detail::merge::sort(a, n);
        else detail::indirect::stable_sort(a, n);
    }
    
    template<typename C>
    static void stable_cmp(T* a, size_t n, C c) {
        constexpr auto sz = detail::traits::size_of<T>();
        if constexpr (sz == detail::traits::Size::TINY || sz == detail::traits::Size::SMALL)
            detail::merge::sort(a, n, c);
        else detail::indirect::stable_sort(a, n, c);
    }
};

// 公共API =========================================================

// 原地排序
template<typename Container>
void sort(Container& c, const Options& opts = Options::default_opts()) {
    using T = typename Container::value_type;
    if constexpr (detail::traits::is_contiguous_v<Container>) {
        if (c.size() >= 2) Sorter<T>::sort(c.data(), c.size(), opts);
    } else {
        std::vector<T> tmp(c.begin(), c.end());
        if (tmp.size() >= 2) {
            Sorter<T>::sort(tmp.data(), tmp.size(), opts);
            std::copy(tmp.begin(), tmp.end(), c.begin());
        }
    }
}

// 带比较器的原地排序
template<typename Container, typename Compare>
void sort(Container& c, Compare comp, const Options& opts = Options::default_opts()) {
    using T = typename Container::value_type;
    if constexpr (detail::traits::is_contiguous_v<Container>) {
        if (c.size() >= 2) Sorter<T>::sort(c.data(), c.size(), comp, opts);
    } else {
        std::vector<T> tmp(c.begin(), c.end());
        if (tmp.size() >= 2) {
            Sorter<T>::sort(tmp.data(), tmp.size(), comp, opts);
            std::copy(tmp.begin(), tmp.end(), c.begin());
        }
    }
}

// 迭代器范围排序
template<typename It>
void sort(It first, It last, const Options& opts = Options::default_opts()) {
    using T = typename std::iterator_traits<It>::value_type;
    auto n = std::distance(first, last);
    if (n >= 2) Sorter<T>::sort(&(*first), static_cast<size_t>(n), opts);
}

// 带比较器的迭代器范围排序
template<typename It, typename Compare>
void sort(It first, It last, Compare comp, const Options& opts = Options::default_opts()) {
    using T = typename std::iterator_traits<It>::value_type;
    auto n = std::distance(first, last);
    if (n >= 2) Sorter<T>::sort(&(*first), static_cast<size_t>(n), comp, opts);
}

// 返回排序副本
template<typename Container>
Container sorted(Container c, const Options& opts = Options::default_opts()) {
    sort(c, opts);
    return c;
}

template<typename Container, typename Compare>
Container sorted(Container c, Compare comp, const Options& opts = Options::default_opts()) {
    sort(c, comp, opts);
    return c;
}

template<typename It>
auto sorted(It first, It last, const Options& opts = Options::default_opts()) {
    using T = typename std::iterator_traits<It>::value_type;
    std::vector<T> result(first, last);
    sort(result, opts);
    return result;
}

template<typename It, typename Compare>
auto sorted(It first, It last, Compare comp, const Options& opts = Options::default_opts()) {
    using T = typename std::iterator_traits<It>::value_type;
    std::vector<T> result(first, last);
    sort(result, comp, opts);
    return result;
}

// 稳定排序
template<typename Container>
void stable_sort(Container& c, const Options& opts = Options::default_opts()) {
    using T = typename Container::value_type;
    if constexpr (detail::traits::is_contiguous_v<Container>) {
        if (c.size() >= 2) Sorter<T>::stable_sort(c.data(), c.size(), opts);
    } else {
        std::vector<T> tmp(c.begin(), c.end());
        if (tmp.size() >= 2) {
            Sorter<T>::stable_sort(tmp.data(), tmp.size(), opts);
            std::copy(tmp.begin(), tmp.end(), c.begin());
        }
    }
}

template<typename Container, typename Compare>
void stable_sort(Container& c, Compare comp, const Options& opts = Options::default_opts()) {
    using T = typename Container::value_type;
    if constexpr (detail::traits::is_contiguous_v<Container>) {
        if (c.size() >= 2) Sorter<T>::stable_sort(c.data(), c.size(), comp, opts);
    } else {
        std::vector<T> tmp(c.begin(), c.end());
        if (tmp.size() >= 2) {
            Sorter<T>::stable_sort(tmp.data(), tmp.size(), comp, opts);
            std::copy(tmp.begin(), tmp.end(), c.begin());
        }
    }
}

template<typename It>
void stable_sort(It first, It last, const Options& opts = Options::default_opts()) {
    using T = typename std::iterator_traits<It>::value_type;
    auto n = std::distance(first, last);
    if (n >= 2) Sorter<T>::stable_sort(&(*first), static_cast<size_t>(n), opts);
}

template<typename It, typename Compare>
void stable_sort(It first, It last, Compare comp, const Options& opts = Options::default_opts()) {
    using T = typename std::iterator_traits<It>::value_type;
    auto n = std::distance(first, last);
    if (n >= 2) Sorter<T>::stable_sort(&(*first), static_cast<size_t>(n), comp, opts);
}

// 辅助函数
template<typename Container>
bool is_sorted(const Container& c) {
    if (c.size() <= 1) return true;
    auto it = c.begin();
    auto prev = *it++;
    while (it != c.end()) {
        if (*it < prev) return false;
        prev = *it++;
    }
    return true;
}

template<typename Container, typename Compare>
bool is_sorted(const Container& c, Compare comp) {
    if (c.size() <= 1) return true;
    auto it = c.begin();
    auto prev = *it++;
    while (it != c.end()) {
        if (comp(*it, prev)) return false;
        prev = *it++;
    }
    return true;
}

template<typename Container>
std::vector<size_t> argsort(const Container& c) {
    std::vector<size_t> idx(c.size());
    std::iota(idx.begin(), idx.end(), size_t(0));
    std::sort(idx.begin(), idx.end(), [&](size_t a, size_t b) {
        return c[a] < c[b];
    });
    return idx;
}

template<typename Container, typename Compare>
std::vector<size_t> argsort(const Container& c, Compare comp) {
    std::vector<size_t> idx(c.size());
    std::iota(idx.begin(), idx.end(), size_t(0));
    std::sort(idx.begin(), idx.end(), [&](size_t a, size_t b) {
        return comp(c[a], c[b]);
    });
    return idx;
}

template<typename Container>
void partial_sort(Container& c, size_t k) {
    if (k == 0 || c.size() <= 1) return;
    if (k >= c.size()) { sort(c); return; }
    std::partial_sort(c.begin(), c.begin() + k, c.end());
}

template<typename Container>
auto nth_element(Container& c, size_t n) -> typename Container::value_type& {
    std::nth_element(c.begin(), c.begin() + n, c.end());
    return c[n];
}

// 便捷别名
template<typename T>
void fyx_sort(T& data, const Options& opts = Options::default_opts()) {
    sort(data, opts);
}

template<typename T, typename Compare>
void fyx_sort(T& data, Compare comp, const Options& opts = Options::default_opts()) {
    sort(data, comp, opts);
}

template<typename T>
auto fyx_sorted(T data, const Options& opts = Options::default_opts()) {
    sort(data, opts);
    return data;
}

template<typename T, typename Compare>
auto fyx_sorted(T data, Compare comp, const Options& opts = Options::default_opts()) {
    sort(data, comp, opts);
    return data;
}

} // namespace fyx

#if defined(FYX_GCC) && defined(FYX_COMPILER_VER) && FYX_COMPILER_VER >= 110000
    #pragma GCC diagnostic pop
#endif

#endif // FYX_SORT_HPP

// 测试程序
#ifdef FYX_MAIN

#include <iostream>
#include <iomanip>
#include <chrono>
#include <random>

// 测试用的大结构体
struct Large { int k; char d[252]; bool operator<(const Large& o) const { return k < o.k; } bool operator==(const Large& o) const { return k == o.k; } };
struct Huge  { int k; char d[1020]; bool operator<(const Huge& o) const { return k < o.k; } bool operator==(const Huge& o) const { return k == o.k; } };

// 性能测试函数
template<typename T, typename G>
void bench(const char* nm, size_t n, G gen, int r = 3) {
    double tf = 0, ts = 0; bool ok = true;
    std::mt19937 rng(42);
    
    for (int i = 0; i < r; ++i) {
        std::vector<T> d(n);
        for (auto& x : d) x = gen(rng);
        
        auto a = d, b = d;
        
        auto t1 = std::chrono::high_resolution_clock::now();
        fyx::sort(a);
        auto t2 = std::chrono::high_resolution_clock::now();
        tf += std::chrono::duration<double, std::milli>(t2 - t1).count();
        
        t1 = std::chrono::high_resolution_clock::now();
        std::sort(b.begin(), b.end());
        t2 = std::chrono::high_resolution_clock::now();
        ts += std::chrono::duration<double, std::milli>(t2 - t1).count();
        
        if (!fyx::is_sorted(a)) ok = false;
        for (size_t j = 0; j < n && ok; ++j) if (!(a[j] == b[j])) ok = false;
    }
    
    std::cout << std::setw(24) << nm << " | " << std::setw(9) << n << " | "
              << std::fixed << std::setprecision(2) << std::setw(9) << tf/r << " ms | "
              << std::setw(9) << ts/r << " ms | " << std::setw(6) << ts/tf << "x | "
              << (ok ? "PASS" : "FAIL") << "\n";
}

int main() {
    std::cout << "\nFYX-SORT v2.0 性能测试\n";
    std::cout << "==============================================================\n\n";
    
    std::cout << "CPU: " << fyx::detail::Config::threads() << " threads | ";
#if defined(FYX_GCC)
    std::cout << "GCC " << __GNUC__ << "." << __GNUC_MINOR__;
#elif defined(FYX_CLANG)
    std::cout << "Clang " << __clang_major__;
#elif defined(FYX_MSVC)
    std::cout << "MSVC " << _MSC_VER;
#endif
#ifdef FYX_AVX2
    std::cout << " | AVX2";
#endif
    std::cout << "\n\n";
    
    // 正确性测试
    std::cout << "=== 正确性测试 ===\n";
    std::mt19937 g(12345);
    bool all_pass = true;
    
    auto test = [&](const char* name, auto fn) {
        std::cout << name << "... ";
        bool pass = fn();
        std::cout << (pass ? "PASS" : "FAIL") << "\n";
        all_pass &= pass;
    };
    
    test("小数组", [&]() {
        for (int n = 1; n <= 32; ++n) {
            std::vector<int> a(n), b;
            for (auto& x : a) x = g() % 1000;
            b = a;
            fyx::sort(a);
            std::sort(b.begin(), b.end());
            if (a != b) return false;
        }
        return true;
    });
    
    test("大随机数据", [&]() {
        std::vector<int> a(100000);
        for (auto& x : a) x = g();
        auto b = a;
        fyx::sort(a);
        std::sort(b.begin(), b.end());
        return a == b;
    });
    
    test("sorted()函数", [&]() {
        std::vector<int> a = {5, 2, 8, 1, 9};
        auto b = fyx::sorted(a);
        return fyx::is_sorted(b) && !fyx::is_sorted(a);
    });
    
    test("自定义比较器", [&]() {
        std::vector<int> a(1000);
        for (auto& x : a) x = g();
        fyx::sort(a, std::greater<int>());
        for (size_t i = 1; i < a.size(); ++i) if (a[i] > a[i-1]) return false;
        return true;
    });
    
    test("大结构体", [&]() {
        std::vector<Large> a(2000);
        for (auto& x : a) x.k = g();
        auto b = a;
        fyx::sort(a);
        std::sort(b.begin(), b.end());
        for (size_t i = 0; i < a.size(); ++i) if (a[i].k != b[i].k) return false;
        return true;
    });
    
    test("稳定排序", [&]() {
        struct S { int k, o; bool operator<(const S& x) const { return k < x.k; } };
        std::vector<S> a(1000);
        for (int i = 0; i < 1000; ++i) a[i] = {int(g() % 50), i};
        fyx::stable_sort(a);
        for (size_t i = 1; i < a.size(); ++i)
            if (a[i].k == a[i-1].k && a[i].o < a[i-1].o) return false;
        return true;
    });
    
    if (!all_pass) {
        std::cout << "\n!!! 测试失败 !!!\n";
        return 1;
    }
    
    std::cout << "\n所有正确性测试通过!\n\n";
    
    // 性能测试
    std::cout << "=== 性能测试 ===\n";
    std::cout << std::setw(24) << "类型" << " | " << std::setw(9) << "大小" << " | "
              << std::setw(13) << "FYX" << " | " << std::setw(13) << "std" << " | "
              << std::setw(8) << "加速比" << " | 结果\n";
    std::cout << std::string(86, '-') << "\n";
    
    std::mt19937 rng(42);
    
    // 整数测试
    for (size_t n : {10000, 100000, 1000000, 10000000})
        bench<int>("int", n, [&](auto& g){ return int(g()); });
    std::cout << std::string(86, '-') << "\n";
    
    // 浮点数测试
    for (size_t n : {10000, 100000, 1000000})
        bench<double>("double", n, [&](auto& g){ 
            return std::uniform_real_distribution<>(-1e9, 1e9)(g); 
        });
    std::cout << std::string(86, '-') << "\n";
    
    // 大结构体测试
    for (size_t n : {5000, 20000, 50000})
        bench<Large>("Large (256B)", n, [&](auto& g){ Large s; s.k = g(); return s; });
    std::cout << std::string(86, '-') << "\n";
    
    // 特殊情况测试
    bench<int>("已排序", 10000000, [i=0]() mutable { return i++; });
    bench<int>("逆序", 10000000, [i=10000000]() mutable { return i--; });
    
    std::cout << "\n测试完成!\n";
    return 0;
}

#endif
